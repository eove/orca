<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ceremony to use the Offline Root CA - O.R.CA&#x27;s documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">O.R.CA&#x27;s documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="using-the-offline-pki"><a class="header" href="#using-the-offline-pki">Using the Offline PKI</a></h1>
<p>Document created from repository <a href="@ORCA@gitremote@">@ORCA@gitremote@</a> at commit :<br />
<code>@ORCA@commit@</code></p>
<h2 id="verifying-this-document"><a class="header" href="#verifying-this-document">Verifying this document</a></h2>
<p>Please follow your organisation's way of verifying a document to make sure this document has not been tampered with.
A gpg-based one can be found at the <a href="../signing_and_verifying.html">signing and verifying annex</a></p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This document explains how to use the Offline Root CA from preparing the ceremony until a report is signed and shared.
That event is called a <em>ceremony</em>.</p>
<p>All commands are given for Linux using a bash shell. Please adapt according to your environment.</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Public_key_certificate">Certificate</a> : Digital identifier for a machine or a service. The certificat is public but can only be used when in possesion of the associated private key.</p>
<p>PKI : <a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">Public-key infrastructure</a></p>
<p>CA : <a href="https://en.wikipedia.org/wiki/Certificate_authority">Certificate Authority</a></p>
<p>CSR/<a href="https://en.wikipedia.org/wiki/Certificate_signing_request">Certificate Signing Request</a> : Certificate proposed to a CA for signature</p>
<p><a href="https://en.wikipedia.org/wiki/Secret_sharing">Secret Sharing</a> : an algorithm to split a secret between multiple people</p>
<p>SSS : <a href="https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing">Shamir Secret Sharing</a></p>
<p>GPG/GnuPG : <a href="https://en.wikipedia.org/wiki/GNU_Privacy_Guard">GNU Privacy Guard</a>. This tool can sign and cypher messages and files thus ensuring their authenticity, integrity and/or confidentiality.</p>
<p><a href="https://en.wikipedia.org/wiki/Digital_signature">Digital signature</a>/Cryptographic signature : Verifiable signature of a digital document, ensuring the authenticity and integrity of the document.</p>
<p>GPG keyring : database containing all the known public keys, and possible associated private keys known from GPG, together with the related level of trust.</p>
<p><a href="https://en.wikipedia.org/wiki/Checksum">Checksum</a> : In this documentation, we use the sha256 <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic hashing function</a> as a secure checksum. A secure checksum is necessary to ensure that the input is not tampered.</p>
<p>Hardware Token/<a href="https://en.wikipedia.org/wiki/Security_token">Security token</a> : a physical device that can securely store secrets (like private keys). This is useful to securely use a secret on any computer.</p>
<p><a href="https://en.wikipedia.org/wiki/YubiKey">Yubikey</a> : Affordable hardware token that can be plugged on a USB port and is compatible with GPG.</p>
<p>Vault/<a href="https://github.com/hashicorp/vault">Hashicorp Vault</a> : Web service to handle secrets and use cryptographic primitives (like CA automation).</p>
<p>Vault Private Data : Database of Hashicorp Vault at rest. This data contains the state of the Vault and <strong>must</strong> be backed up to ensure the vault and the managed PKI is not lost.</p>
<p>Unseal share : A part of a secret that allows unsealing a Hashicorp Vault. Multiple shares are necessary in order to unseal a vault. Reaching that threshold is called reaching a quorum.</p>
<p>Unseal a Hashicorp Vault : A sealed vault cannot be used because it doesn't know the key to decypher the private data. To get that secret, a quorum is necessary and the vault is then unsealed.</p>
<p>Seal a Hashicorp Vault : An unsealed vault can be sealed by anyone having the corresponding right in Vault.</p>
<p>Token : An access token generated after a proof of identity (via login or certificate).</p>
<p>Root token : A token with <strong>every rights</strong> on Hashicorp Vault.</p>
<p>Ephemeral Vault : A Hashicorp Vault started for a one-time usage on a machine. Private data may be given when starting the vault and are saved one the vault is stopped. This is used to handle the Offline part of the PKI, thus the machine running the ephemeral vault should also be offline.</p>
<p>Ceremony : An event during which operations are performed on the offline part of the PKI. This event is formalized, planned and produce an auditable report.</p>
<p>Ceremony report : Auditable document, cryptographically signed, describing the context, the people involved and the actions that occured during a ceremony.</p>
<p>Trusted commit : The sha of a git commit which has been audited and that can be trusted.</p>
<p>ISO/<a href="https://en.wikipedia.org/wiki/ISO_9660">ISO9660</a> : file system format for optical disc (extended for bootable USB sticks).
For an ephemeral vault, that image contains the whole operating system and script. It is thus umutable and self contained.</p>
<p>Bootable live media : Mass storage with a ISO9660 image loaded.</p>
<p>Vault writable partition : secondary partition on the ephemeral vault bootable live media.
Unlike the ISO partition, this partition is in read/write mode.
It contains everything that changes during a ceremony (e.g. the vault private data, logs, certificates‚Ä¶)</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<h3 id="architecture-of-the-vault-system"><a class="header" href="#architecture-of-the-vault-system">Architecture of the vault system</a></h3>
<p>One of the key feature of the vault system is to handle a Public-Key Infrastructure (PKI).</p>
<p>The whole chain of trust starts with the root Certificate Authority (CA). That's why it must be kept as secured as possible.</p>
<p>To achieve this, the PKI (and thus the vault system) is split in two parts:</p>
<ul>
<li>the offline CAs, that contain multiple CAs, one of them is the root CA (topmost root of trust).<br />
All of these offline CAs are manipulated using the offline vault.<br />
The offline vault is not a machine, it is a database (a set of backup files) fetched into an ephemeral machine when manipulating the online CAs.</li>
<li>the online CAs which are used on a daily basis.</li>
</ul>
<p>In the offline vault, the root CA delegates its signing rights to offline intermediate CAs that are restricted to a given subdomain.
This offline intermediate CA will then delegate its signing rights to an online intermediate CA that is valid for a short amount of time.
It is up to the online intermediate CA to sign certificates on a day to day basis.</p>
<p>Here is a graphical representation of the chain of trust:</p>
<pre class="mermaid">flowchart TD

    subgraph Offline vault
        ROOT_CA&gt;&quot;&lt;b&gt;ROOT CA&lt;/b&gt;
*.example.com
fa:fa-hourglass 30yrs&quot;]
        INTERMEDIATE_CA&gt;&quot;&lt;b&gt;Offline intermediate CA&lt;/b&gt;
*.subdomain.example.com
fa:fa-hourglass 30yrs&quot;]
    end
    ROOT_CA --&gt; |delegates| INTERMEDIATE_CA

    INTERMEDIATE_CA --&gt; |delegates| VAULT_PKI

    subgraph Online vault
        VAULT_PKI&gt;&quot;&lt;b&gt;Online intermediate CA&lt;/b&gt;
*.subdomain.example.com
fa:fa-hourglass 14yrs&quot;]
        VAULT_PKI --&gt;|signs| EOCON1(&quot;fa:fa-barcode
        XXX.subdomain.example.com
fa:fa-hourglass 12yrs&quot;)
        VAULT_PKI --&gt;|signs| EOCON2(&quot;fa:fa-barcode
        YYY.subdomain.example.com
fa:fa-hourglass 12yrs&quot;)
    end
</pre>
<h3 id="secret-sharing-system"><a class="header" href="#secret-sharing-system">Secret sharing system</a></h3>
<p>Since the vault system protects highly sensitive data (like the root CA), it must be impossible for a single person to manipulate it.
Hashicorp vault encrypts (aka seals) every secret it stores. Thus, even if you have access to vault's database's files, you cannot read or change any data in that database without the encryption key.</p>
<p>The encryption key is never stored anywhere. Instead, it is split into multiple parts called "shares".
Each share is securely given to a different human being that <em>must</em> keep it secret. We call these people "share holders".
To decrypt (aka unseal) vault's database, a number of shares higher than a threshold is necessary.
This is called a quorum.</p>
<p>A good starting point is to be split among at least 5 share holders (the more the merrier) and a quorum of at least 3 people.</p>
<p>The downside of that technique is that we <em>must</em> verify regularly that we can reach a quorum.
If we lose our ability to reach a quorum, then the whole PKI is lost forever.
Here are some events that may impact our ability to reach a quorum:</p>
<ul>
<li>people may lose their share</li>
<li>people may leave the company</li>
</ul>
<p>Thus it is important to:</p>
<ul>
<li>regularly check that all share holders still have access to their share</li>
<li>revoke the shares owned by people leaving the company</li>
<li>keep the number of shares high by regularly creating shares for people entering the company</li>
<li>make sure that share holders can keep their share securely (in a safe encrypted storage)</li>
</ul>
<p>The first 3 items are taken care of by running the periodical check workflow.
THe 4th item is garanteed by the fact shares are only stored encrypted, by the fact the decryption process uses secure hardware token (Yubikeys) and by the fact the cleartext share is never disclosed, and only input to the vault unseal process by an automated process (scripts).</p>
<h3 id="note-on-scripts"><a class="header" href="#note-on-scripts">Note on scripts</a></h3>
<blockquote>
<p>[!Note]<br />
Every path and command given in this documentation is relative to the <a href="@ORCA@gitremote@">O.R.CA git repository</a>.</p>
</blockquote>
<blockquote>
<p>[!Warning]<br />
Every command given in this documentation is written for <code>bash</code>.<br />
In case you have a warning on experimental nix commands, you may suffix <code>nix</code> commands with the following options:</p>
<ul>
<li><code>--extra-experimental-features nix-command</code></li>
<li><code>--extra-experimental-features flakes</code></li>
</ul>
</blockquote>
<blockquote>
<p>[!Important]<br />
Every change must go through a script. No action should be manually performed on a vault.</p>
</blockquote>
<h2 id="planning-a-ceremony"><a class="header" href="#planning-a-ceremony">Planning a ceremony</a></h2>
<p>This whole chapter has to be done <em>before</em> the day of the ceremony.</p>
<h3 id="creating-a-team-to-work-on-the-vault-system"><a class="header" href="#creating-a-team-to-work-on-the-vault-system">Creating a team to work on the vault system</a></h3>
<p>Initially, one person should take care of organising an official ceremony to manipulate the offline vault.
This person is called the <code>organiser</code> (üì¢).</p>
<p>To perform the actual work on the vault system, the organiser will need to gather a team of at least 2 tech-savy people.
These people are called the <code>team members</code> (üë•), the üì¢<code>organiser</code> can be one of them.
These people will perform preparative work <em>before</em> the ceremony and they will be present <em>during</em> the ceremony.</p>
<div class="mdbook-alerts mdbook-alerts-important">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  important
</p>
<p>All üë•<code>team members</code> should have a hardware token (Yubikey) that secures their unseal share. They will need this to both unseal the vault and sign the report.</p>
</div>
<p>The üì¢<code>organiser</code> should communicate to all üë•<code>team members</code> the list of operations (and therefore scripts) that will be performed during the ceremony. The aforementionned scripts should be commited to the <code>src/scripts/actions</code> directory of this repository prior to the verification phase.</p>
<h4 id="configuring-the-ceremony"><a class="header" href="#configuring-the-ceremony">Configuring the ceremony</a></h4>
<p>The üì¢<code>organiser</code> should know which environment will be worked on (<code>prod</code>/<code>preprod</code>), modify the value of <code>orca.environment-target</code> in <a href="../../src/default.nix">src/default.nix</a> accordingly, and notify this environment to all üë•<code>team members</code>.</p>
<p>The üì¢<code>organiser</code> should get the value of the cvault present in the last report and set the value of <code>orca.latest_cvault</code> in <a href="../../src/default.nix">src/default.nix</a> accordingly. If the ceremony is the first one for this environment, then <code>null</code> should be set. The üì¢<code>organiser</code> is encourage to verify the validity of the report in the same way the üë•<code>team members</code> <a href="#verification-of-the-last-ceremonys-report">will do during the verification phase</a>.</p>
<p>The üì¢<code>organiser</code> should know what will be done during the ceremony and set the values of <code>orca.actions_in_order</code> and <code>orca.rotate_keys</code> in <a href="../../src/default.nix">src/default.nix</a> accordingly.</p>
<h4 id="updating-the-version-of-the-offline-vault"><a class="header" href="#updating-the-version-of-the-offline-vault">Updating the version of the offline vault</a></h4>
<p>The software we are using to run the <em>ephemeral vault</em> should not be obsolete (to allow for smooth migration of data, and avoid any unpatched security weakness).</p>
<p>Check if there is any new stable release that is more recent than what is specified in <a href="../../../src/flake.nix">src/flake.nix</a>'s <code>inputs.nixpkgs.url</code>. If so, we should try to upgrade to the lastest stable release.</p>
<p>If a new stable release exists, then upgrade it in the input part of the flake.
Otherwise update the <code>flake.lock</code> to the most up-to-date packages by running:</p>
<pre><code class="language-bash">cd src/
nix flake update
</code></pre>
<p>Once changes have been performed, commit the modified files to the <a href="@ORCA@gitremote@">O.R.CA repository</a>.</p>
<h4 id="insertingchecking-up-to-date-gpg-public-keys"><a class="header" href="#insertingchecking-up-to-date-gpg-public-keys">Inserting/checking up-to-date GPG public keys</a></h4>
<div class="mdbook-alerts mdbook-alerts-warning">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  warning
</p>
<p>This section should only be executed if there was any change in the set of keys in use. In all other cases, please skip to the next section.</p>
</div>
<p>The üì¢<code>organiser</code> asks all <code>share holders</code> (including üë•<code>team members</code>) to check that the hardware token they own has its public key recorded in the env-specific directory located under [<code>src/share_holders_keys/</code>] in this repository and if it needs to be updated or added, they should do it via a signed commit.</p>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>Github automatically signs commits performed via the online Github web interface.</p>
</div>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>The public key can be checked with the corresponding hardware token plugged in and with the public key imported in gpg.<br />
For this, enter the following command:<br />
<code>echo "It works" | gpg -e -f /path/to/public/key.pub | gpg -d</code></p>
</div>
<h4 id="setting-up-the-trusted-commit"><a class="header" href="#setting-up-the-trusted-commit">Setting up the trusted commit</a></h4>
<p>When all scripts planned for the ceremony are ready and all keys are up-to-date, the üì¢<code>organiser</code> writes down the last git commit of repo <a href="@ORCA@gitremote@">O.R.CA</a> containing all re-inserted keys, and communicates this commit to all üë•<code>team members</code>.</p>
<p>For the rest of this documentation, we are going to name that commit the <code>trusted commit</code> (‚úÖ)</p>
<div class="mdbook-alerts mdbook-alerts-important">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  important
</p>
<p>That commit should not change until the end of the procedure. If it does, for any valid reason, then you should restart the whole process from the beginning.</p>
</div>
<h3 id="verification-of-the-offline-cas"><a class="header" href="#verification-of-the-offline-cas">Verification of the offline CAs</a></h3>
<div class="mdbook-alerts mdbook-alerts-important">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  important
</p>
<p>While performing verification steps, you should be outside of a <code>nix develop</code>. You may need to deactivate your <code>direnv</code> for this.</p>
</div>
<h4 id="verification-of-the-last-ceremonys-report"><a class="header" href="#verification-of-the-last-ceremonys-report">Verification of the last ceremony's report</a></h4>
<p>First, we will verify the report of the last ceremony.</p>
<div class="mdbook-alerts mdbook-alerts-warning">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  warning
</p>
<p>This section should not be executed at the first initialisation of the vault because we have no previous report. In that case, please skip to the next section.</p>
</div>
<p>This step <em>must</em> be performed by all üë•<code>team members</code> <em>before</em> the day of the ceremony</p>
<p>Get the last report for the corresponding environment and verify the signatures following your organisation's way of verifying a document.
A gpg-based one can be found at the <a href="../signing_and_verifying.html">signing and verifying annex</a></p>
<blockquote>
<p>[!Warning]<br />
All signatures should be valid. The check above should be valid for at least the 3 üë•<code>team members</code> of the previous ceremony.</p>
<p>Only <strong>one</strong> invalid/missing signature is enough to <strong>stop the ceremony</strong>. In such a case, the issue should be analysed.</p>
</blockquote>
<p>Once all signatures has been verified, to get ready for subsequent steps, extract from the <code>previous ceremony report</code>:</p>
<ul>
<li>the <code>trusted commit</code> that was used back then (that we will refer to as <code>previous trusted commit</code>)</li>
<li>the checksum <em>C<sub>vault</sub></em> of the previous vault private data that was computed when closing down the ceremony back then.</li>
</ul>
<h4 id="verifying-bootable-live-media-related-changes"><a class="header" href="#verifying-bootable-live-media-related-changes">Verifying bootable live media related changes</a></h4>
<p>This step <em>must</em> be performed by all üë•<code>team members</code> <em>before</em> the day of the ceremony</p>
<div class="mdbook-alerts mdbook-alerts-warning">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  warning
</p>
<p>At the first initialisation of the vault, the <code>previous ceremony trusted commit</code> mentionned below is unknown, so instead we will take the commit at which this workflow document was generated (<code>@ORCA@commit@</code>).</p>
</div>
<p>Before doing anything with the new ‚úÖ<code>trusted commit</code>, we need to verify all potential changes done to the offline vault since the last <code>previous ceremony trusted commit</code>.</p>
<p>To do so, checkout the current ‚úÖ<code>trusted commit</code>:</p>
<pre><code class="language-bash">git checkout &lt;trusted commit&gt;
</code></pre>
<p>Then:</p>
<pre><code class="language-bash">git diff &lt;previous ceremony trusted commit&gt; src/
</code></pre>
<div class="mdbook-alerts mdbook-alerts-important">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  important
</p>
<ul>
<li>The only changes you see should be in the orca's nix configuration and in the actions scripts in <code>src/scripts/actions</code>.</li>
<li>The ceremony's configuration (environment, cvault, etc‚Ä¶) that <a href="#configuring-the-ceremony">has been set by the üì¢<code>organiser</code></a> should be verified.</li>
<li>Any change displayed by the diff should be considered legitimate to you.</li>
<li>During this step, üë•<code>team members</code> will also review and understand all the scripts that are planned for execution during the ceremony.</li>
<li>Scripts should never ask the offline topmost root CA to sign anything that doesn't strictly remains in the offline vault (no external CSR).</li>
<li>If the offline CA is signing a CSR from a third party (for example online) CA, the authenticity of the CSR file should be checked. Please consult your online PKI documentation to know how to authentify the emitter of the CSR.</li>
</ul>
</div>
<p>Once all üë•<code>team members</code> have validated the new ‚úÖ<code>trusted commit</code>, each of them will gather some fingerprinting data concerning the bootable media that will be used during the ceremony:</p>
<p>Start by building a bootable iso image:</p>
<pre><code class="language-bash">nix build src/.#iso-offline
</code></pre>
<p>Compute the size of the verifiable bytes (total size - 512) that we will call <em>N<sub>iso</sub></em>:</p>
<pre><code class="language-bash">export Niso=$(expr $(stat --format=%s -L result/iso/orca-*.iso) - 512) &amp;&amp;\
 echo "Niso=$Niso"
</code></pre>
<p>Compute a sha256 checksum <em>C<sub>iso</sub></em> of the verifiable bytes:</p>
<pre><code class="language-bash">export ISO_FILENAME=$(command ls result/iso/orca-*.iso | head -n 1)
dd status=none if=${ISO_FILENAME} bs=512 skip=1 |\
 sha256sum -b | sed -E 's/^([[:xdigit:]]*).*$/Ciso=\1/'
</code></pre>
<p>Communicate the values of <em>N<sub>iso</sub></em> and <em>C<sub>iso</sub></em> to the other üë•<code>team members</code>.</p>
<h4 id="creation-of-a-bootable-live-media-for-the-vault"><a class="header" href="#creation-of-a-bootable-live-media-for-the-vault">Creation of a bootable live media for the vault</a></h4>
<p>The bootable live media should be created by one üë•<code>team member</code> <em>before</em> the day of the ceremony. This person will be the üìù<code>reporter</code> during the ceremony.</p>
<p>In order to create a bootable live USB media, we will need a physical USB stick (Kanguru FlashTrust with S/N 2110142010043) that has a physical write protection switch.</p>
<blockquote>
<p>[!Warning]<br />
The example below assumes <code>/dev/sda</code> is the Linux device name that will be fully erased and where the <em>ephemeral vault</em> software is going to be installed, please adapt to your setup.</p>
</blockquote>
<p>In order to create this bootable live media, that we will refer to as <em>ephemeral vault</em> in the rest of these instructions, we will execute the following command from the root of the vault repository:</p>
<blockquote>
<p>[!Warning]<br />
Make sure you are doing this on the ‚úÖ<code>trusted commit</code></p>
</blockquote>
<pre><code class="language-bash">nix run src/.#create-usb-vault /dev/sda
</code></pre>
<blockquote>
<p>[!Warning]<br />
The content of the device provided as argument will be completely destroyed</p>
</blockquote>
<p>By default, this script will create 3 partitions on the <em>ephemeral vault</em> media, among which the following are important to us:</p>
<ul>
<li>a bootable partition with label <code>orca-${TARGET_VAULT}</code> contains the <em>ephemeral vault</em> software</li>
<li>a partition with label <code>VAULT_WRITABLE</code> contains the offline CA private data (is mounted on <code>/var/lib/vault</code>) when the <em>ephemeral vault</em> boots</li>
</ul>
<p>You can check that with :</p>
<pre><code class="language-bash">lsblk -o name,label
</code></pre>
<div class="mdbook-alerts mdbook-alerts-warning">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  warning
</p>
<p>The rest of this section should not be executed at the first initialisation of the vault because we have no previous backup. In that case, please skip to the next section.</p>
</div>
<p>Fetch offline CA private data backup for the corresponding environment (eg: prod, preprod etc.).</p>
<p>The content of the previous offline vault private data should be extracted and put into the <code>VAULT_WRITABLE</code> partition.</p>
<p>If the USB stick's partitions have been mounted automatically by your distro, the following will help in finding out the mount point for the <code>VAULT_WRITABLE</code> content:</p>
<pre><code class="language-bash">lsblk -o name,mountpoint,label,size | grep VAULT_WRITABLE
</code></pre>
<p>If the above fails, then you will have to mount the <code>VAULT_WRITABLE</code> partition (manually on the CLI or by opening the volume in your file manager).<br />
In the examples below, we use <code>/VAULT_WRITABLE/mount/point</code> as the mount point.</p>
<p>You can extract the tar archive of the vault private data with:</p>
<pre><code class="language-bash">sudo tar --same-owner -xvf ORCA_backup.tar -C /VAULT_WRITABLE/mount/point
</code></pre>
<blockquote>
<p>[!Tip]<br />
You can double-check that the data is correct with:<br />
<code>cd /VAULT_WRITABLE/mount/point &amp;&amp; sudo find . -type f -exec sha256sum -b {} \; | sort -k2 | sha256sum -</code><br />
You should get the same checksum as the value <em>C<sub>vault</sub></em> indicated in the <code>previous report</code>.</p>
</blockquote>
<h2 id="executing-the-ceremony"><a class="header" href="#executing-the-ceremony">Executing the ceremony</a></h2>
<p>3 roles <em>must</em> be assigned during the execution of the ceremony.<br />
2 of them will be distributed to already nominated üë•<code>team members</code> who all should also have at hand their own copy of the validated ceremony's workflow document.</p>
<div class="mdbook-alerts mdbook-alerts-important">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  important
</p>
<p>The <code>observer</code> (üëÄ) should be <strong>randomly</strong> picked up. More on this below.</p>
</div>
<p>These 3 persons should be <strong>physically present during the whole ceremony</strong>, and <strong>have their hardware token with them</strong>.</p>
<ol>
<li>
<p>The first role is the <code>operator</code> (üíª).<br />
This person is the one typing the commands during the verification phase and manipulates the <code>observer</code>'s computer.<br />
They follow their own copy of this workflow document.</p>
</li>
<li>
<p>The second role is the <code>reporter</code> (üìù).<br />
This person has their own copy of this ceremony workflow document.<br />
This person <strong>must</strong> be the person that created the USB stick.<br />
During the whole ceremony, this person will fill in the sections framed with a <span style="border:2px dotted dodgerblue;padding-left:2px;padding-right:2px;">dotted-blue border</span>.</p>
</li>
</ol>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>To extract these sections from the html version of the ceremony's workflow, use the following filter:<br />
<code>cat /path/to/ceremory_workflow.html | sed -e 's|&lt;\([/]\)*code class="language-report"&gt;|\n&lt;\1\@ORCA\@report\@&gt;\n|g' | sed -n -e '/&lt;\@ORCA\@report\@&gt;/,/&lt;\/\@ORCA\@report\@&gt;/{s/&lt;[/]*\@ORCA\@report\@&gt;//;p}' | sed -e '$a\@GPG\@SIGNATURES\@' | tee /tmp/blank_report.txt</code></p>
</div>
<ol start="3">
<li>The third role is the <code>observer</code> (üëÄ).<br />
This person should be <a href="https://www.random.org/lists/">randomly</a> picked among all share holders except the two other üë•<code>team members</code>. The random draw will be performed by either the üíª<code>operator</code> or üìù<code>reporter</code>.<br />
The üëÄ<code>observer</code> will lend their computer to run the <em>ephemeral vault</em>. This machine must have a Linux x86_64 OS installed.<br />
They must be sitting next to the üíª<code>operator</code>. Gets the validated ceremony workflow from the üíª<code>operator</code>, and validates that the ceremony is done <em>exactly</em> as documented.<br />
Make sure that this computer has more than one USB port available:
<ul>
<li>one without adapter nor hub. This port will be used for the O.R.CA stick during the whole ceremony.</li>
<li>one or more USB port that fits the USB format of the Yubikeys (USB-A, USB-C etc.).</li>
</ul>
</li>
</ol>
<p>For the rest of the procedure below, you can consider references to üë•<code>team members</code> as a synonym for the group of the 3 roles above.</p>
<div class="mdbook-alerts mdbook-alerts-important">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  important
</p>
<p>In the report below, and only when initializing the vault the first time, a few <code>FAIL</code>ed items are expected.<br />
They are identified with a star in the report like this <code>FAIL* []</code></p>
</div>
<table width=100% style="border:2px dotted dodgerblue;"><td style="padding:0;">
<pre><code class="language-report">Name of the organiser:
...............................................................................

Revision of the ceremony workflow used:
@ORCA@rev@

Version (commit) of the workflow document:
@ORCA@commit@

Names of the team members that participate to the ceremony:
Operator: .....................................................................
Reporter: .....................................................................
Observer: .....................................................................
These 3 roles are handled by 3 different people ............. PASS [] / FAIL []
These 3 people are located in the same physical room ........ PASS [] / FAIL []

Date of the ceremony:
...............................................................................

Target environment:
.......................................................... preprod [] / prod []
Trusted commit for the new ceremony:
...............................................................................

Date of the previous ceremony:
...............................................................................
Previous trusted commit (as read from the previous ceremony's report):
...............................................................................
Previous backup sha256 checksum (as read from the previous ceremony's report):
...............................................................................

The ceremony's workflow document (valid rev, signatures) have been checked by:
the operator ................................................ PASS [] / FAIL []
the reporter ................................................ PASS [] / FAIL []

The previous ceremony's report signatures have been verified by:
the operator ............................................... PASS [] / FAIL* []
the reporter ............................................... PASS [] / FAIL* []

The verifiable bytes of the iso are (value of *Niso*):
...............................................................................
The sha256 checksum of the *N* verifiable bytes is (value of *Ciso*):
...............................................................................

The review of changes/content of the bootable live media has been performed by:
the operator ................................................ PASS [] / FAIL []
the reporter ................................................ PASS [] / FAIL []
All changes are legitimate ....................... PASS [] / FAIL []

A key rotation will be performed (Yes/No) : ...............

Scripts that will be executed during the maintenance phase:
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................

A bootable live media has been generated for this ceremony ........... PASS [] / FAIL []
The team member who brings the bootable media is the reporter: ....... PASS [] / FAIL []

The offline CA private data has been restored from the following archive file:
...............................................................................

</code></pre>
</td></table>
<h3 id="verifying-then-booting-the-ephemeral-vault"><a class="header" href="#verifying-then-booting-the-ephemeral-vault">Verifying then booting the <em>ephemeral vault</em></a></h3>
<p>The machine of the üëÄ<code>observer</code> will be used during the whole ceremony to verify and boot the <em>ephemeral vault</em>. That machine can be any x86_64 PC able to boot on a live media.</p>
<div class="mdbook-alerts mdbook-alerts-warning">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  warning
</p>
<p>Only the üìù<code>reporter</code> is allowed to touch the bootable live media.</p>
</div>
<div class="mdbook-alerts mdbook-alerts-warning">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  warning
</p>
<p>The <em>ephemeral vault</em> machine should not be connected to any IP network.<br />
All cables attached to the machine should be evaluated, especially USB-C power supplied.</p>
</div>
<p>To check the key:</p>
<ul>
<li>Before inserting the USB stick, the üìù<code>reporter</code> switches the physical button of the stick to <em>read-only</em>. The stick <em>must stay on read-only until it is successfully booted</em></li>
<li>The following steps must be performed without booting on the USB stick, with the USB stick still in <em>read-only</em> mode, and directly on the installed Linux OS of the üëÄ<code>observer</code>'s computer.</li>
<li>An environment variable <code>Niso</code> should be set with the correct value, then the key is verified by the üíª<code>operator</code> (number of partitions, <em>N<sub>iso</sub></em> checksum):</li>
</ul>
<pre><code class="language-bash">sudo fdisk -l /dev/sda &amp;&amp;\
 sudo dd if=/dev/sda bs=512 skip=1 count=$(expr $Niso / 512) |\
 sha256sum -b
</code></pre>
<ul>
<li>the result sha256 should match the value <em>C<sub>iso</sub></em> computed from the ‚úÖ<code>trusted commit</code>.</li>
</ul>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>The example above assumes <code>/dev/sda</code> is the Linux device name for the bootable live media. Please adapt to your setup.</p>
</div>
<p>If the checksum <em>C<sub>iso</sub></em> is correct and only the first partition is bootable:</p>
<ul>
<li>Power off the üëÄ<code>observer</code>'s computer.</li>
<li>The üëÄ<code>observer</code>'s computer is rebooted once more on the USB stick.</li>
</ul>
<p>When booting <em>ephemeral vault</em>, a NixOS logo will appear with a boot menu mentionning <code>O.R.CA xxxx</code>.</p>
<table width=100% style="border:2px dotted dodgerblue;"><td style="padding:0;">
<pre><code class="language-report">The key with the vault iso image is set as read only ........ PASS [] / FAIL []

The operator's machine:
can select the key as boot device ........................... PASS [] / FAIL []
can successfully complete boot on the readonly key .......... PASS [] / FAIL []

While performing the USB stick content check on the operator's machine:
the first partition is the only one marked as bootable ............... PASS [] / FAIL []
the checksum *Ciso* is correct ....................................... PASS [] / FAIL []
the computer has been powered off while the USB stick was still read-only .. PASS [] / FAIL []

The key for the ephemeral vault is then set as read/write and the ephemeral ...
vault is immediately booted ................................. PASS [] / FAIL []
</code></pre>
</td></table>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>If you get errors while booting, make sure your key has been switched to <em>read/write</em>.</p>
</div>
<p>From now on, the ceremony will run automatically while stopping after each step to let the üë•<code>team members</code> time to validate everything is going as planned and fill the report.</p>
<p>A message is printed on the screen indicating the the stick can now be switched to <em>read/write</em>.</p>
<div class="mdbook-alerts mdbook-alerts-warning">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  warning
</p>
<p>If anything goes wrong, the ceremony will stop and all data except the audit logs and the screen recording will be wiped.</p>
</div>
<h3 id="checking-boot-time-verifications"><a class="header" href="#checking-boot-time-verifications">Checking boot-time verifications</a></h3>
<p>In order to be sure that offline private data has not been tampered with (or downgraded to an old state), at boot, we compute a cryptographically secure checksum on the vault private data <em>C<sub>vault</sub></em>, that should match the <em>C<sub>vault</sub></em> announced in the previous ceremony's report.</p>
<p>After booting, that computed checksum is displayed on the screen, as well as the existing root token count (that should be 0) and the vault status.</p>
<table width=100% style="border:2px dotted dodgerblue;"><td style="padding:0;">
<pre><code class="language-report">The vault private data checksum displayed at boot (_Cvault_) matches the ......
previous ceremony's backup sha256 checksum ................. PASS [] / FAIL* []
0 token exists in the vault private data at startup ......... PASS [] / FAIL []
The vault service status returns "Initialized" = true ...... PASS [] / FAIL* []
The vault service status returns "Sealed" = true ............ PASS [] / FAIL []
</code></pre>
</td></table>
<h3 id="unsealing-the-ephemeral-vault"><a class="header" href="#unsealing-the-ephemeral-vault">Unsealing the <em>ephemeral vault</em></a></h3>
<div class="mdbook-alerts mdbook-alerts-warning">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  warning
</p>
<p>This section should not be executed at the first initialisation of the vault. In that case, please skip to the next section.</p>
</div>
<p>After a reboot, the vault will be in sealed status.</p>
<p>In order to unseal the vault, you will need to gather enough participants that have an unseal key share to reach the minimum quorum.</p>
<p>On the <em>ephemeral vault</em>, insert each <code>team member</code>'s hardware tokens one after the other when instructed to.</p>
<p>¬†<br></p>
<table width=100% style="border:2px dotted dodgerblue;"><td style="padding:0;">
<pre><code class="language-report">The offline vault has been unsealed ........................ PASS [] / FAIL* []
Share holders that participated to the unseal process:
...............................................................................
...............................................................................
...............................................................................
</code></pre>
</td></table>
<h3 id="maintenance-operations-on-the-offline-cas"><a class="header" href="#maintenance-operations-on-the-offline-cas">Maintenance operations on the offline CAs</a></h3>
<p>Each maintenance script (key rotation, csr signature, CA creation, ...) will now be performed.</p>
<table width=100% style="border:2px dotted dodgerblue;"><td style="padding:0;">
<pre><code class="language-report">All maintenance script has been executed successfully ....... PASS [] / FAIL []
</code></pre>
</td></table>
<h2 id="closing-down-the-ceremony"><a class="header" href="#closing-down-the-ceremony">Closing down the ceremony</a></h2>
<p>To close the ceremony, a serie of actions will be performed leading to a safe shutdown of the <em>ephemeral vault</em> and a backup of the state of the vault.</p>
<h3 id="root-token-revocation-check"><a class="header" href="#root-token-revocation-check">Root token revocation check</a></h3>
<p>First, the the vault will be sealed. Then the number of remaining root tokens will be displayed.</p>
<p><code>0</code> should be displayed</p>
<table width=100% style="border:2px dotted dodgerblue;"><td style="padding:0;">
<pre><code class="language-report">The vault has been sealed ................................... PASS [] / FAIL []
0 token exists in the vault private data before backup ...... PASS [] / FAIL []
</code></pre>
</td></table>
<h3 id="backup-and-offline-vault-private-data-checksum"><a class="header" href="#backup-and-offline-vault-private-data-checksum">Backup and offline vault private data checksum</a></h3>
<p>While the <em>ephemeral vault</em> is sealed, we have access to the vault private data inside the <code>VAULT_WRITABLE</code> partition.</p>
<p>This data needs to be backed-up to retain the last state of the offline vault.</p>
<p>The script will create a tar archive of the data in the <code>VAULT_WRITABLE</code> partition.</p>
<p>The value <em>C<sub>vault</sub></em> is displayed on the <em>ephemeral vault</em>'s terminal, together with its graphical representation as a QR code. It is a checksum over the vault private data folder.<br />
All üë•<code>team members</code> should keep a copy of this <em>C<sub>vault</sub></em> value. It will be used to verify that the backup was not altered when extracted from the USB stick.</p>
<p>To finish the ceremony, the stick must be switched to <em>read-only</em> mode and stay that way <strong>until the end of the ceremony's workflow</strong>.</p>
<p>The <em>ephemeral vault</em> will then switch off.</p>
<p>One of the üë•<code>team members</code> inserts the USB stick on their own computer.</p>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>The preferred üë•<code>team member</code> to do this is the üìù<code>reporter</code> because it allows to speed up the process, but this is not mandatory.<br />
Indeed, if it is the üìù<code>reporter</code>, then as soon as the archive is sent (see the lines below), the report can be completed and signed by the üìù<code>reporter</code> asynchronously while the other üë•<code>team member</code> perform verifications.</p>
</div>
<p>The üë•<code>team member</code> that inserted the USB stick, immediately:</p>
<ol>
<li>copies the tar archive from the <code>VAULT_WRITABLE</code> partition to the backup destination corresponding to the environment.</li>
<li>sends the tar archive from the <code>VAULT_WRITABLE</code> partition to all the participants as an attached file via e-mail</li>
<li>gets the AIA data in folder <code>orca/aia/</code> of the current environment (prod/preprod) from <code>VAULT_WRITABLE</code> partition data and makes it available on the online vault.</li>
</ol>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>We use a tar format here because it allows for deduplication during the enterprise-wide backup process (that includes all Google Drive content)</p>
</div>
<p>All üë•<code>team members</code> should now:</p>
<ol>
<li>download the attached private data archive from the e-mail they have received</li>
<li>download a copy of the private data archive from the drive</li>
</ol>
<p>On both these archives, they should perform a checksum of this data with the following command:</p>
<pre><code class="language-bash">export VAULT_BACKUP=/path/to/ORCA_backup.tar
(export TMP_DIR="$(mktemp -d)" &amp;&amp;\
 cd "$TMP_DIR" &amp;&amp;\
 sudo tar --same-owner -xf "$VAULT_BACKUP" -C . &amp;&amp;\
 sudo find . -type f -exec sha256sum -b {} \; | sort -k2 | sha256sum -)
</code></pre>
<p>The value displayed should match <em>C<sub>vault</sub></em> grabbed from the QR code above.</p>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>In the backup archive, üë•<code>team members</code> will also have access to the session recording.<br />
All sessions are stored in <code>orca/recordings/ceremony-*.cast</code>, and can be viewed using:<br />
<code>nix develop --command asciinema cat /path/to/orca/recordings/ceremony.cast</code></p>
</div>
<table width=100% style="border:2px dotted dodgerblue;"><td style="padding:0;">
<pre><code class="language-report">The vault private data archive has been safely stored ....... PASS [] / FAIL []
The checksum of the tar file content matches _Cvault_ ....... PASS [] / FAIL []
Value of the full sha256 checksum of the vault private data folder (_Cvault_):
...............................................................................
</code></pre>
</td></table>
<h3 id="signing-and-saving-the-report"><a class="header" href="#signing-and-saving-the-report">Signing and saving the report</a></h3>
<p>Before signing the report, please verify its content, specifically:</p>
<ul>
<li>the value of the ‚úÖ<code>trusted commit</code></li>
<li>the value of the sha256 checksum of the new offline vault private data (C<sub>vault</sub>)</li>
<li>name the report to contain the date of the ceremony, for example: <em>ceremony-report-preprod-2025-03-17</em></li>
</ul>
<p>The üìù<code>reporter</code>, üíª<code>operator</code>, and üëÄ<code>observer</code> will all sign the report by following your organisation's way of signing documents.
A gpg-based one can be found at the <a href="../signing_and_verifying.html">signing and verifying annex</a></p>
<p>All üë•<code>team members</code> should now get a copy of the signed report and perform a check of all signatures using <a href="#verification-of-the-last-ceremonys-report">the same process as when checking the last ceremony's report</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../signing_and_verifying.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../workflow/periodical_checks.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../signing_and_verifying.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../workflow/periodical_checks.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../docs/.style/mermaid.min.js"></script>
        <script src="../docs/.style/mermaid-init.js"></script>


    </div>
    </body>
</html>
