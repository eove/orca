<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Periodical checks of the PKI - O.R.CA&#x27;s documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">O.R.CA&#x27;s documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="periodical-checks-of-the-pki"><a class="header" href="#periodical-checks-of-the-pki">Periodical checks of the PKI</a></h1>
<p>Document created from repository <a href="@ORCA@gitremote@">@ORCA@gitremote@</a> at commit :<br />
<code>@ORCA@commit@</code></p>
<h2 id="verifying-this-document"><a class="header" href="#verifying-this-document">Verifying this document</a></h2>
<p>Please follow your organisation's way of verifying a document to make sure this document has not been tampered with.
A gpg-based one can be found at the <a href="../signing_and_verifying.html">signing and verifying annex</a></p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This document explains how to periodically verify the PKI and its usability.
Executing this workflow may require performing changes on the offline PKI, and thus executing an offline ceremony.</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Public_key_certificate">Certificate</a> : Digital identifier for a machine or a service. The certificat is public but can only be used when in possesion of the associated private key.</p>
<p>PKI : <a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">Public-key infrastructure</a></p>
<p>CA : <a href="https://en.wikipedia.org/wiki/Certificate_authority">Certificate Authority</a></p>
<p>CSR/<a href="https://en.wikipedia.org/wiki/Certificate_signing_request">Certificate Signing Request</a> : Certificate proposed to a CA for signature</p>
<p><a href="https://en.wikipedia.org/wiki/Secret_sharing">Secret Sharing</a> : an algorithm to split a secret between multiple people</p>
<p>SSS : <a href="https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing">Shamir Secret Sharing</a></p>
<p>GPG/GnuPG : <a href="https://en.wikipedia.org/wiki/GNU_Privacy_Guard">GNU Privacy Guard</a>. This tool can sign and cypher messages and files thus ensuring their authenticity, integrity and/or confidentiality.</p>
<p><a href="https://en.wikipedia.org/wiki/Digital_signature">Digital signature</a>/Cryptographic signature : Verifiable signature of a digital document, ensuring the authenticity and integrity of the document.</p>
<p>GPG keyring : database containing all the known public keys, and possible associated private keys known from GPG, together with the related level of trust.</p>
<p><a href="https://en.wikipedia.org/wiki/Checksum">Checksum</a> : In this documentation, we use the sha256 <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic hashing function</a> as a secure checksum. A secure checksum is necessary to ensure that the input is not tampered.</p>
<p>Hardware Token/<a href="https://en.wikipedia.org/wiki/Security_token">Security token</a> : a physical device that can securely store secrets (like private keys). This is useful to securely use a secret on any computer.</p>
<p><a href="https://en.wikipedia.org/wiki/YubiKey">Yubikey</a> : Affordable hardware token that can be plugged on a USB port and is compatible with GPG.</p>
<p>Vault/<a href="https://github.com/hashicorp/vault">Hashicorp Vault</a> : Web service to handle secrets and use cryptographic primitives (like CA automation).</p>
<p>Vault Private Data : Database of Hashicorp Vault at rest. This data contains the state of the Vault and <strong>must</strong> be backed up to ensure the vault and the managed PKI is not lost.</p>
<p>Unseal share : A part of a secret that allows unsealing a Hashicorp Vault. Multiple shares are necessary in order to unseal a vault. Reaching that threshold is called reaching a quorum.</p>
<p>Unseal a Hashicorp Vault : A sealed vault cannot be used because it doesn't know the key to decypher the private data. To get that secret, a quorum is necessary and the vault is then unsealed.</p>
<p>Seal a Hashicorp Vault : An unsealed vault can be sealed by anyone having the corresponding right in Vault.</p>
<p>Token : An access token generated after a proof of identity (via login or certificate).</p>
<p>Root token : A token with <strong>every rights</strong> on Hashicorp Vault.</p>
<p>Ephemeral Vault : A Hashicorp Vault started for a one-time usage on a machine. Private data may be given when starting the vault and are saved one the vault is stopped. This is used to handle the Offline part of the PKI, thus the machine running the ephemeral vault should also be offline.</p>
<p>Ceremony : An event during which operations are performed on the offline part of the PKI. This event is formalized, planned and produce an auditable report.</p>
<p>Ceremony report : Auditable document, cryptographically signed, describing the context, the people involved and the actions that occured during a ceremony.</p>
<p>Trusted commit : The sha of a git commit which has been audited and that can be trusted.</p>
<p>ISO/<a href="https://en.wikipedia.org/wiki/ISO_9660">ISO9660</a> : file system format for optical disc (extended for bootable USB sticks).
For an ephemeral vault, that image contains the whole operating system and script. It is thus umutable and self contained.</p>
<p>Bootable live media : Mass storage with a ISO9660 image loaded.</p>
<p>Vault writable partition : secondary partition on the ephemeral vault bootable live media.
Unlike the ISO partition, this partition is in read/write mode.
It contains everything that changes during a ceremony (e.g. the vault private data, logs, certificatesâ€¦)</p>
<h2 id="protocole-de-vÃ©rification"><a class="header" href="#protocole-de-vÃ©rification">Protocole de vÃ©rification</a></h2>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<h3 id="architecture-of-the-vault-system"><a class="header" href="#architecture-of-the-vault-system">Architecture of the vault system</a></h3>
<p>One of the key feature of the vault system is to handle a Public-Key Infrastructure (PKI).</p>
<p>The whole chain of trust starts with the root Certificate Authority (CA). That's why it must be kept as secured as possible.</p>
<p>To achieve this, the PKI (and thus the vault system) is split in two parts:</p>
<ul>
<li>the offline CAs, that contain multiple CAs, one of them is the root CA (topmost root of trust).<br />
All of these offline CAs are manipulated using the offline vault.<br />
The offline vault is not a machine, it is a database (a set of backup files) fetched into an ephemeral machine when manipulating the online CAs.</li>
<li>the online CAs which are used on a daily basis.</li>
</ul>
<p>In the offline vault, the root CA delegates its signing rights to offline intermediate CAs that are restricted to a given subdomain.
This offline intermediate CA will then delegate its signing rights to an online intermediate CA that is valid for a short amount of time.
It is up to the online intermediate CA to sign certificates on a day to day basis.</p>
<p>Here is a graphical representation of the chain of trust:</p>
<pre class="mermaid">flowchart TD

    subgraph Offline vault
        ROOT_CA&gt;&quot;&lt;b&gt;ROOT CA&lt;/b&gt;
*.example.com
fa:fa-hourglass 30yrs&quot;]
        INTERMEDIATE_CA&gt;&quot;&lt;b&gt;Offline intermediate CA&lt;/b&gt;
*.subdomain.example.com
fa:fa-hourglass 30yrs&quot;]
    end
    ROOT_CA --&gt; |delegates| INTERMEDIATE_CA

    INTERMEDIATE_CA --&gt; |delegates| VAULT_PKI

    subgraph Online vault
        VAULT_PKI&gt;&quot;&lt;b&gt;Online intermediate CA&lt;/b&gt;
*.subdomain.example.com
fa:fa-hourglass 14yrs&quot;]
        VAULT_PKI --&gt;|signs| EOCON1(&quot;fa:fa-barcode
        XXX.subdomain.example.com
fa:fa-hourglass 12yrs&quot;)
        VAULT_PKI --&gt;|signs| EOCON2(&quot;fa:fa-barcode
        YYY.subdomain.example.com
fa:fa-hourglass 12yrs&quot;)
    end
</pre>
<h3 id="note-on-scripts"><a class="header" href="#note-on-scripts">Note on scripts</a></h3>
<blockquote>
<p>[!Note]<br />
Every path and command given in this documentation is relative to the <a href="@ORCA@gitremote@">O.R.CA git repository</a>.</p>
</blockquote>
<blockquote>
<p>[!Warning]<br />
Every command given in this documentation is written for <code>bash</code>.<br />
In case you have a warning on experimental nix commands, you may suffix <code>nix</code> commands with the following options:</p>
<ul>
<li><code>--extra-experimental-features nix-command</code></li>
<li><code>--extra-experimental-features flakes</code></li>
</ul>
</blockquote>
<blockquote>
<p>[!Important]<br />
Every change must go through a script. No action should be manually performed on a vault.</p>
</blockquote>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>In order to execute the current document, you will need:</p>
<ul>
<li>An initialised offline vault</li>
<li>An initialised and running online vault</li>
<li>To fulfill all the prerequisites to run an ceremony</li>
</ul>
<h2 id="recurrent-checks"><a class="header" href="#recurrent-checks">Recurrent checks</a></h2>
<p>On a regular basis, the whole PKI usability should be assessed, this means that <strong>all</strong> the following checks should pass or be fixed by an action described in each chapter.</p>
<p>Checks (and fixes) below should be performed first on the preprod environment, then on prod.
If fixes are needed, this means running a ceremony on preprod, and then a ceremony on prod.</p>
<div class="mdbook-alerts mdbook-alerts-warning">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  warning
</p>
<p>In order to use scripts on the offline vault, they should be copied and adapted from the directory <code>templates/</code> to <code>src/scripts/</code>, then added to git and only then, the build of the live bootable media will make these scripts available from the command line on the offline terminal.</p>
</div>
<h3 id="yubikeys-certificates-that-have-expired-should-be-renewed"><a class="header" href="#yubikeys-certificates-that-have-expired-should-be-renewed">Yubikeys certificates that have expired should be renewed</a></h3>
<p>Yubikeys' certificates last for at most 8 years.</p>
<p>Every year, we are expecting a minimum of 1 share to be renewed.</p>
<div class="mdbook-alerts mdbook-alerts-warning">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  warning
</p>
<p>An absolute maximum of no more than the total number of shares - the quorum number be renewed during the same share rotation.
This maximum is set to prevent from locking us out of unsealing vaults during the share rotation.
If you plan to rotate this maximum number of shares, you should make sure that the non-renewed key are still usable before regenerating the keys on the hardware tokens.</p>
</div>
<p>Renewal for all currently in-use Yubikeys should be spread over the full validity period of Yubikeys certificates.
Taking 8 years as the default validity, if we have 11 valid shares (Yubikeys), then we should have a schedule of 2 Yubikeys regeneration per year for the first 3 years and 1 Yubikey for the next 5 years.
This is especially important when initially generating certificates on Yubikeys. Many Yubikeys will not be initially valid for the whole 8 years.</p>
<h4 id="test"><a class="header" href="#test">Test</a></h4>
<p>Yubikeys certificates expire on 30/12 of the year mentioned in their public key filename (as registered in the folder <code>share_holders/</code>)
If a Yubikey certificate is expired when performing this check, then it should be renewed.</p>
<p>The ðŸ“¢<code>organiser</code> should perform this check and ask the relevant share holders to renew their Yubikey's GPG key pair.</p>
<h4 id="fix"><a class="header" href="#fix">Fix</a></h4>
<p>Yubikey's GPG public key should be updated and commited by their owner in the relevant folder <code>share_holders/</code>.<br />
The filename storing the Yubikey's public key should follow the template:<br />
<code>2024_firstname.lastname@email.com_yubikey-62413455.pub</code><br />
Where:</p>
<ul>
<li><code>2024</code> is the expiry year of the Yubikey (it will expire on 30/12/2024), you can double-check the expiry using <code>gpg /path/to/file.pub</code></li>
<li><code>firstname.lastname@email.com</code> is the email address of the owner of this Yubikey</li>
<li><code>62413455</code> is the serial number of the Yubikey (as displayed, for example using <code>gpg --card-status</code>)</li>
</ul>
<p>Once all relevant GPG keys have been renewed and their public key commited to the repository, the following script should be run in a ceremony for the offline vault:<br />
<code>templates/unauthenticated/rotate-seal-shares.sh</code></p>
<p>An unseal share rotation should be run also on the online vault.</p>
<h3 id="every-share-holder-can-use-the-unseal-share-they-own"><a class="header" href="#every-share-holder-can-use-the-unseal-share-they-own">Every share holder can use the unseal share they own</a></h3>
<p>And every share holder with a Yubikey should have a GPG public key registered in the folder <code>share_holders/</code></p>
<p>Every share holder runs the following tests with their Yubikey inserted</p>
<h4 id="test-1"><a class="header" href="#test-1">Test</a></h4>
<pre><code class="language-bash">gpg --card-status
</code></pre>
<p>This should return the serial number of the Yubikey.</p>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>If you have an error message <code>gpg: selecting card failed: No such device</code> and/or <code>gpg: OpenPGP card not available: No such device</code>, try to run:<br />
<code>pkill gpg-agent</code></p>
</div>
<p>If the Yubikey is communicating properly, we will extract its key ID:</p>
<pre><code class="language-bash">export GPG_HW_TOKEN_KEY_ID=$(gpg --card-status | sed -n -E -e 's/^[^:]*sign[^:]*:[[:blank:]]*((:?[[:xdigit:]]{4}[[:blank:]]*){10})/\1/pi') &amp;&amp; echo "$GPG_HW_TOKEN_KEY_ID"
</code></pre>
<p>Now let's test that the yubikey actually works (can decrypt data when it's the targeted recipient, and matches a correctly exported public GPG key):</p>
<pre><code class="language-bash">export TMP_GPG_HOME=$(mktemp -d)
cp ~/.gnupg/*.conf "$TMP_GPG_HOME"/
gpg --home="$TMP_GPG_HOME" --import /path/to/src/share_holders_keys/env/*
gpg --home="$TMP_GPG_HOME" --list-keys --keyid-format LONG --with-colons | sed -n -e '/^pub/{n;p}' | sed -n -E 's/^fpr:([^:]*:){8}([^:]*).*$/\2:6:/p' | gpg --home="$TMP_GPG_HOME" --import-ownertrust
echo "It works" | gpg --home="$TMP_GPG_HOME" -e -r "$GPG_HW_TOKEN_KEY_ID" | gpg -d
</code></pre>
<p>If the message <code>It works</code> is displayed, then your Yubikey is usable. This test is a PASS.<br />
If not, the Yubikey owner should notify the organiser.<br />
If at least one share holder fails to use their Yubikey even after troubleshooting, the organiser will organise the fix below.</p>
<h4 id="fix-1"><a class="header" href="#fix-1">Fix</a></h4>
<p>The GPG keypair should be regenerated on the Yubikey of concern, keeping in mind that the new certificate generated on that Yubikey should still have the same expiry date as initially (to keep a correct spread of expiry dates).</p>
<p>The process is detailed <a href="@ORCA@gitremote@/blob/main/docs/yubikeys.html#generating-a-new-opengpg-key">here</a>.</p>
<p>Once a new keypair has been set up on the Yubikey, extract your public key and update the env-specific directory located under folder <code>src/share_holders_keys/</code> in this repository.</p>
<p>Finally, force an unseal share rotation by executing the following script. It should be run in a ceremony for the offline vault:<br />
<code>templates/unauthenticated/rotate-seal-shares.sh</code></p>
<p>An unseal share rotation should be run also on the online vault.</p>
<h3 id="all-target-shared-holders-should-have-a-hardware-token-attributed"><a class="header" href="#all-target-shared-holders-should-have-a-hardware-token-attributed">All target shared holders should have a hardware token attributed</a></h3>
<p>Every shareholder should have a Yubikey, and these Yubikey's GPG keys' details should match their owner's name and e-mail address at the company.</p>
<p>Every share holder runs the following tests with their Yubikey inserted</p>
<h4 id="test-2"><a class="header" href="#test-2">Test</a></h4>
<pre><code class="language-bash">gpg --card-status
</code></pre>
<p>The details of your Yubikey will be displayed, including the serial number, that should match the <a href="https://drive.google.com/drive/folders/1NJg2EfFr1zx0L8r91-SeJX-d9baYWthM">Share holders spreadsheet, both in preprod and prod folder</a>.</p>
<p>The following command will get the username and email address associated with your Yubikey.</p>
<pre><code class="language-bash">gpg --card-status  | sed -n -e '/^General key info/,//p' | sed -n -e 's@^.*pub[[:blank:]][[:blank:]]*@@p'
</code></pre>
<p>The username should match your identity, the e-mail address should be yours (@company.com).</p>
<p>If this is the case, this test is a PASS.<br />
If not, the Yubikey owner should notify the organiser.<br />
If at least one share holder fails to use their Yubikey even after troubleshooting, the organiser will organise the fix below.</p>
<h4 id="fix-2"><a class="header" href="#fix-2">Fix</a></h4>
<p>The GPG keypair should be regenerated on the Yubikey of concern, keeping in mind that the new certificate generated on that Yubikey should still have the same expiry date as initially (to keep a correct spread of expiry dates).</p>
<p>The process is detailed <a href="@ORCA@gitremote@/blob/main/docs/yubikeys.html#generating-a-new-opengpg-key">here</a>.</p>
<p>Once a new keypair has been setup on the Yubikey, extract your public key and update the env-specific directory located under folder <code>src/share_holders_keys/</code> in this repository.</p>
<p>Finally, force an unseal share rotation by executing the following script. It should be run in a ceremony for the offline vault:<br />
<code>templates/unauthenticated/rotate-seal-shares.sh</code></p>
<p>An unseal share rotation should be run also on the online vault.</p>
<h3 id="valid-certificates-can-be-issued-by-the-online-ca-during-the-next-18-months-to-come"><a class="header" href="#valid-certificates-can-be-issued-by-the-online-ca-during-the-next-18-months-to-come">Valid certificates can be issued by the online CA during the next 18 months to come</a></h3>
<p>The online CA that signs device certificates should be able to perform valid signatures until the next recurrent check (plus some margin), that is to say, for the next 18 months.</p>
<h4 id="test-3"><a class="header" href="#test-3">Test</a></h4>
<p>Take the current date now, it will be called <em>D<sub>now</sub></em>. Add 18 months to <em>D<sub>now</sub></em>, then add again the duration of devices certificates. The result is a date <em>D<sub>min</sub></em>.</p>
<p>In order to get the expiry date of the online CA currently in use to sign devices, run the following command against the <strong>online vault</strong> after being logged in to the vault using an account with <strong>admin</strong> privileges:</p>
<pre><code class="language-bash">vault read -format=json devices_pki/issuer/default/json | jq -r '.data.certificate' | openssl x509 -noout -text
</code></pre>
<p>The start of validity date will be called <em>D<sub>start</sub></em>, it can be found in the <code>Validity</code>'s <code>Not Before</code> attribute displayed by the command above.
The expiry date will be called <em>D<sub>expiry</sub></em>, it can be found in the <code>Validity</code>'s <code>Not After</code> attribute displayed by the command above.</p>
<p>The following statement should be true:
<em>D<sub>start</sub></em>&lt;<em>D<sub>now</sub></em> <strong>and</strong> <em>D<sub>expiry</sub></em>&gt;<em>D<sub>min</sub></em>.
If this is the case, this test is a PASS.<br />
If not, a new online CA should be generated, the fix below should be applied.</p>
<h4 id="fix-3"><a class="header" href="#fix-3">Fix</a></h4>
<p>A new device signing online CA should be created, signed by the offline CA and setup to replace the current online CA in use.</p>
<div class="mdbook-alerts mdbook-alerts-warning">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  warning
</p>
<p>The previous device signing online CAs should however <strong>not be revoked</strong>.</p>
</div>
<p>Before starting to generate a new device signing CA certificate, connect to the online vault and write down the current <strong>default</strong> issuer ID (linked to the current certificate):</p>
<pre><code class="language-bash">vault read -format=json devices_pki/issuer/default/json | jq -r '.data.issuer_id'
</code></pre>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>This obviously only applies to renewal of the device signing CA's certificate, not to the initial generation of the very first device signing only CA.</p>
</div>
<p>Set your vault environment:</p>
<pre><code class="language-bash">export TARGET_VAULT=preprod
</code></pre>
<p>or</p>
<pre><code class="language-bash">export TARGET_VAULT=prod
</code></pre>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>External CA generation should not be allowed on the online CA and would probably thus fail due to access rights.<br />
This is on purpose, to prevent the private key of the generated CA from being exposed.<br />
We are thus using internal generation.</p>
</div>
<p>Generate a new <strong>internal</strong> CA CSR on the online vault, by running the following script against the <strong>online vault</strong>:</p>
<pre><code class="language-bash">./scripts/maintenance/create-devices-csr.sh
</code></pre>
<p>Copy the template <code>templates/authenticated/sign-csr.sh</code> into <code>src/scripts/authenticated</code> and embed the CSR content inside that copied version of the script.</p>
<p>This CSR content (PEM-formatted file) will be reviewed during the verification phase of the ceremony workflow.</p>
<p>Finally, on the offline vault, organise an ceremony to execute the updated sign-csr script. The organiser should also direct all team members to the instructions below. Indeed, these provide step-by-step instructions on how to make sure the CSR comes from the online vault.</p>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>Because the online vault has been configured to only generate internal CSR (the associated private key never leaves the vault), we are sure that if the CSR is coming from the online vault, then only that vault can use it and is seen as trusted by the offline vault.</p>
</div>
<p>When the CSR is generated, it is uniquely identified by its PKID property (called <code>subject_key_id</code> in hashicorp vault's terminology).</p>
<p>This PKID value should be identical between:</p>
<ul>
<li>the PEM-formatted CSR (that will be inlined inside the <code>sign-csr</code> script).</li>
<li>the online vault that emitted the CSR.</li>
</ul>
<p>You can copy the following lines in a file and run the script to automatically do that check.</p>
<pre><code class="language-bash">#!/usr/bin/env bash

set -e

CSR="$1"

if [ -z $CSR ]
then
    echo "Usage $0 /path/to/file.csr"
    exit -1
fi

# Get the PKID of the given CSR
SUBJECT_PUBLIC_KEY_OFFS=$(cat "$CSR"  | openssl asn1parse -i | sed -n -E -e 's/^[[:blank:]]*([^:]*):.*BIT STRING.*/\1/p' | head -1)
PKID=$(cat "$CSR" | openssl asn1parse -i -strparse $SUBJECT_PUBLIC_KEY_OFFS -noout -out - | sha1sum -b | sed -n -E -e 's/^([[:alnum:]]+).*/\1/p')

# Login to vault
case $TARGET_VAULT in
    "prod")
        export VAULT_ADDR="https://vault.url.company.com:8200"
        ;;
    "preprod")
        export VAULT_ADDR="https://preprod.url.company.com:8200"
        ;;
esac
vault login -method=github

# Check that this PKID comes from the vault
KEYS=$(vault list devices_pki/keys | sed -n -e '/^[[:xdigit:]][[:xdigit:]\-]*$/p')
for KEY in $KEYS
do
    if [[ $(vault read -format=json devices_pki/key/$KEY | jq -r '.data.subject_key_id' | sed -e 's/://g' ) == "$PKID" ]]
    then
        cat &lt;&lt; EOF
ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰
CSR comes from vault
ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰
EOF
        exit
    fi
done

cat &lt;&lt; EOF
ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€
CSR was not found in vault
ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€
EOF
exit -42
</code></pre>
<div class="mdbook-alerts mdbook-alerts-important">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  important
</p>
<p>The way vault computes the PKID is badly documented and may change in the future.
This means that, if that script succeeds, you can trust that CSR.
However, if it fails, then it can either be a wrong CSR <strong>or</strong> a change in vault. Please check accordingly.</p>
</div>
<p>Once the check have been performed, a ceremony is executed on the offline CA and the CSR is signed, we should get a certificate chain output PEM file, let's store it into <code>/tmp/online_cert.pem</code>.
We now enable the signed private/public key pair for online PKI by running the following script against the <strong>online vault</strong>:</p>
<pre><code class="language-bash">./scripts/maintenance/import-signed-devices-certificate.sh /tmp/online_cert.pem
</code></pre>
<p>Once this has been done, in order to be sure that the imported certificate corresponds to a CSR generated by the online vault, please make sure that the current <strong>default</strong> issuer ID for the devices PKI has changed from the value you initially wrote down above:</p>
<pre><code class="language-bash">vault read -format=json devices_pki/issuer/default/json | jq -r '.data.issuer_id'
</code></pre>
<div class="mdbook-alerts mdbook-alerts-important">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  important
</p>
<p>If the default issuer ID has not been updated, there may be a security risk. The imported PEM certificate could have been generated by another machine than the online vault and trust chain may be at risk.<br />
This is even more important if the CSR PKID property (aka <code>subject_key_id</code>) could not be properly verified in the previous steps above.<br />
In such situations, you should immediately <a href="../../revocation.html">revoke (and publish) the PEM that the offline vault just signed</a>. This requires running a new ceremony.</p>
</div>
<h3 id="the-offline-ca-can-sign-new-online-intermediate-cas-for-their-whole-lifetime-during-the-next-12-months-to-come"><a class="header" href="#the-offline-ca-can-sign-new-online-intermediate-cas-for-their-whole-lifetime-during-the-next-12-months-to-come">The offline CA can sign new online intermediate CAs for their whole lifetime during the next 12 months to come</a></h3>
<p>The offline root CA signs offline intermediate CAs that last for many years.
Before the offline root CA becomes obsolete and thus cannot sign new intermediate CAs, a new offline root CA should be generated.</p>
<p>In such a case (a new offline root CA is generated), then all trust chain down to the device certification authority should be re-generated as well. This is tedious and should be done in advance (not in emergency), and well before the new offline root CA is actually used, so that all third parties (telemonitoring services) have time to update their list of trusted CAs (add the new one alongside the existing one).</p>
<p>Only when all third parties are trusting the new chain will we be free to swap the existing offline tree with a new one.</p>
<h4 id="test-4"><a class="header" href="#test-4">Test</a></h4>
<p>Take the current date now, it will be called <em>D<sub>now</sub></em>. Add 18 months to <em>D<sub>now</sub></em>, then add again the duration of the online CA. The result is a date <em>D<sub>min</sub></em>.</p>
<p>In order to get the expiry date of the offline CA in the trust chain used to sign devices, run the following command against the <strong>online vault</strong> after being logged in to the vault using an account with <strong>admin</strong> privileges:</p>
<pre><code class="language-bash">vault read -format=json devices_pki/issuer/default/json | jq -r '.data.certificate' | openssl x509 -noout -text
</code></pre>
<p>Check the section called <code>Authority Information Access</code>, specifically the <code>CA Issuers</code> URI, that can be used to fetch the certificate of the offline CA that certifies the currently used online CA. We will store this URI in an environment variable <code>ONLINE_CA_ISSUER_URI</code> that we will use in the command below.</p>
<p>Download and dump the offline CA's certificate:</p>
<pre><code>curl "$ONLINE_CA_ISSUER_URI" | openssl x509 -inform DER -noout -text
</code></pre>
<p>The expiry date will be called <em>D<sub>expiry</sub></em>, it can be found in the <code>Validity</code>'s <code>Not After</code> attribute displayed by the command above.</p>
<p>The following statement should be true:
<em>D<sub>expiry</sub></em>&gt;<em>D<sub>min</sub></em>.
If this is the case, this test is a PASS.<br />
If not, a new offline CA should be generated, the fix below should be applied.</p>
<h4 id="fix-4"><a class="header" href="#fix-4">Fix</a></h4>
<p>We will need a new device signing offline CA, which also probably implies that a new root offline CA should be created as well.
You have two options there:</p>
<ul>
<li>Either the current offline root CA can be rotated (see https://developer.hashicorp.com/vault/tutorials/pki/pki-engine#step-7-rotate-root-ca)<br />
This requires writing scripts for this to be run on the offline <em>ephemeral vault</em>.</li>
<li>Or you can create a brand new offline root CA.<br />
This would be a brand new start of the root CA and this means re-initializing a new vault, start from an empty backup etc.<br />
Please read <a href="../offline/PKI_INit/md">the documentation on how to setup a new PKI</a>.</li>
</ul>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>In any case, the old PKI (and offline CAs) are still valid for at least 6 months, so you can use them up to the end of their validity. After their validity has elapsed, the expired CAs should be kept as read-only and won't be used anymore (except if revokation is required).</p>
</div>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>When renewing the root CA, you may as well evaluate the following aspects:</p>
<ul>
<li>is the crypto used for the trust chain still up-to-date or should it be updated?</li>
<li>is hashicorp vault still up-to-date and maintained, in general and in NixOS or should the PKI be setup using new tools?</li>
<li>the environment in which the vault has been created initially has been progressively migrated from an initialization state 30 years before, it's maybe time to clean-up and start from scratch.</li>
<li>restarting from scratch allows to detach the currently active PKI from all history of previously chained reports and audit trails.</li>
<li>we may want to start with better security ecosystem (better crypto, improved initialisation in both hashicorp vault and our own scripts) after 30 years, it's probably time to review the whole setup in depth, including scripts, hashicorp vault, tools (hardware tokens, NixOS bootable media), and where and how backups+reports are saved.</li>
<li>after 30 years, it would be good to get new people own the whole system, including setup from scratch</li>
<li>you have 6 months...</li>
</ul>
</div>
<h3 id="the-next-periodical-check-is-planned"><a class="header" href="#the-next-periodical-check-is-planned">The next periodical check is planned</a></h3>
<p>A new periodical check should be planned within 1 year.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../workflow/offline_vault_ceremony.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../gpg_public_key.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../workflow/offline_vault_ceremony.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../gpg_public_key.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../docs/.style/mermaid.min.js"></script>
        <script src="../docs/.style/mermaid-init.js"></script>


    </div>
    </body>
</html>
